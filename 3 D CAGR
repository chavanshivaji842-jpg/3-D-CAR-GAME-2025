<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>3D Car Racing (Offline)</title>
  <style>
    :root { --ui: rgba(255,255,255,0.9); }
    body { margin: 0; overflow: hidden; background:#000; font-family: system-ui, Arial; }
    canvas { display:block; }

    /* HUD */
    #hud {
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      color:#fff; font-weight:700; font-size:18px; z-index:10;
      text-shadow:0 2px 6px rgba(0,0,0,0.6);
    }
    #sub {
      font-size:14px; opacity:0.85; font-weight:500; margin-top:4px; text-align:center;
    }

    /* Game Over dialog */
    #gameover {
      position:fixed; inset:0; display:none; place-items:center; z-index:20;
      background:rgba(0,0,0,0.5);
    }
    #card {
      background: var(--ui); color:#111; padding:18px 20px; border-radius:14px; width:280px;
      text-align:center; box-shadow:0 10px 30px rgba(0,0,0,0.35);
    }
    #restart {
      margin-top:12px; padding:10px 14px; font-weight:700; border:none; border-radius:10px;
      background:#ff4747; color:#fff; cursor:pointer;
    }

    /* Mobile controls */
    .controls {
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      display:flex; gap:18px; z-index:12;
    }
    .btn {
      width:64px; height:64px; border-radius:50%; border:2px solid rgba(255,255,255,0.35);
      background:rgba(255,255,255,0.15); color:#fff; font-size:24px; font-weight:800;
      box-shadow:0 6px 14px rgba(0,0,0,0.35); backdrop-filter: blur(6px);
      user-select:none;
    }
  </style>
</head>
<body>

  <!-- HUD -->
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="sub">‚ö†Ô∏è Offline mode ‚Ä¢ No internet required</div>
  </div>

  <!-- Game Over -->
  <div id="gameover">
    <div id="card">
      <div style="font-size:20px; font-weight:800;">üí• Game Over</div>
      <div id="final" style="margin-top:6px;">Score: 0</div>
      <button id="restart">Restart</button>
    </div>
  </div>

  <!-- Mobile Controls -->
  <div class="controls">
    <button class="btn" id="left">‚¨ÖÔ∏è</button>
    <button class="btn" id="up">‚¨ÜÔ∏è</button>
    <button class="btn" id="down">‚¨áÔ∏è</button>
    <button class="btn" id="right">‚û°Ô∏è</button>
  </div>

  <!-- OFFLINE: use your locally uploaded three.min.js path here -->
  <script src="SRC_THREE_MIN_JS_HERE"></script>

  <script>
    // ------------- BASIC THREE SETUP -------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 30, 120);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // ------------- WORLD (OFFLINE PRIMITIVES) -------------
    // Road
    const roadW = 12, roadL = 600;
    const road = new THREE.Mesh(
      new THREE.PlaneGeometry(roadW, roadL, 1, 1),
      new THREE.MeshPhongMaterial({ color:0x333333 })
    );
    road.rotation.x = -Math.PI/2;
    road.position.z = -200;
    scene.add(road);

    // Lane markings
    const markings = [];
    const laneCount = 3;
    const laneW = roadW / laneCount;
    const markGeom = new THREE.PlaneGeometry(0.2, 3);
    const markMat = new THREE.MeshBasicMaterial({ color:0xffffff });
    for (let i=0;i<60;i++){
      for (let j=1;j<laneCount;j++){
        const m = new THREE.Mesh(markGeom, markMat);
        m.rotation.x = -Math.PI/2;
        m.position.set(j*laneW - roadW/2, 0.01, -i*8);
        scene.add(m); markings.push(m);
      }
    }

    // Simple buildings (sides) for parallax
    const buildings = [];
    const bGeom = new THREE.BoxGeometry(6, 8, 6);
    for (let i=0;i<20;i++){
      const mat = new THREE.MeshLambertMaterial({ color: (Math.random()*0x808080)|0x404040 });
      const L = new THREE.Mesh(bGeom, mat);
      L.position.set(-roadW/2 - 5, 4, -i*25);
      const R = L.clone(); R.position.x = roadW/2 + 5;
      scene.add(L, R); buildings.push(L, R);
    }

    // ------------- PLAYER CAR (PRIMITIVE OFFLINE MODEL) -------------
    const car = new THREE.Group();
    // Body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.6, 3),
      new THREE.MeshStandardMaterial({ color:0xff3b30, roughness:0.3, metalness:0.2 })
    );
    body.position.y = 0.6;
    car.add(body);
    // Cabin
    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.5, 1.4),
      new THREE.MeshStandardMaterial({ color:0x222222, roughness:0.8, metalness:0.0 })
    );
    cabin.position.set(0, 1.0, -0.2);
    car.add(cabin);
    // Wheels
    function wheel(x,z){
      const w = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35,0.35,0.4,16),
        new THREE.MeshStandardMaterial({ color:0x111111 })
      );
      w.rotation.z = Math.PI/2; w.position.set(x,0.35,z);
      return w;
    }
    car.add(wheel( 0.7,  1.0), wheel(-0.7,  1.0), wheel( 0.7, -1.0), wheel(-0.7, -1.0));
    scene.add(car);
    car.position.set(0,0,2);

    // ------------- GAME STATE -------------
    let speed = 0.22;         // forward speed
    let score = 0;
    let gameOver = false;

    const obstacles = [];
    const boosters = [];

    // Obstacle (red)
    function spawnObstacle(){
      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshPhongMaterial({ color:0xff4040 })
      );
      cube.position.set((Math.random()-0.5)*(roadW-2), 0.5, -120);
      scene.add(cube); obstacles.push(cube);
    }
    // Booster (green)
    function spawnBooster(){
      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(1,1,1),
        new THREE.MeshPhongMaterial({ color:0x00d26a })
      );
      cube.position.set((Math.random()-0.5)*(roadW-2), 0.5, -120);
      scene.add(cube); boosters.push(cube);
    }

    // Timers
    let obsTimer = 0, boostTimer = 0;

    // ------------- INPUT (KB + TOUCH) -------------
    const keys = {};
    addEventListener('keydown', e=> keys[e.key]=true);
    addEventListener('keyup',   e=> keys[e.key]=false);

    function touchHold(btnId, key){
      const el = document.getElementById(btnId);
      let hold=false;
      el.addEventListener('touchstart', e=>{ e.preventDefault(); keys[key]=true; hold=true; });
      el.addEventListener('touchend',   e=>{ e.preventDefault(); keys[key]=false; hold=false; });
    }
    touchHold('up','ArrowUp'); touchHold('down','ArrowDown');
    touchHold('left','ArrowLeft'); touchHold('right','ArrowRight');

    // ------------- HUD / UI -------------
    const scoreEl = document.getElementById('score');
    const goBox   = document.getElementById('gameover');
    const finalEl = document.getElementById('final');
    document.getElementById('restart').onclick = ()=> location.reload();

    // ------------- AUDIO (PURE OFFLINE, WEB AUDIO) -------------
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const actx = new AudioCtx();
    let musicStarted = false;

    function beep(freq=440, time=0.12, type='sine', gain=0.08){
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value = gain;
      o.connect(g); g.connect(actx.destination);
      o.start();
      o.stop(actx.currentTime + time);
    }

    // Simple background "pulse" music loop
    let musicInterval = null;
    function startMusic(){
      if(musicStarted) return;
      musicStarted = true;
      // Little side-chain pulse
      musicInterval = setInterval(()=>{
        // chord-ish pulses
        beep(220, 0.10, 'sawtooth', 0.03);
        setTimeout(()=>beep(277,0.10,'sawtooth',0.03), 120);
        setTimeout(()=>beep(330,0.10,'sawtooth',0.03), 240);
      }, 750);
    }
    function stopMusic(){
      if(musicInterval) clearInterval(musicInterval);
    }
    addEventListener('keydown', ()=> actx.state==='suspended' ? actx.resume().then(startMusic) : startMusic());
    addEventListener('touchstart', ()=> actx.state==='suspended' ? actx.resume().then(startMusic) : startMusic());

    function sfxCrash(){ // descending chirp
      beep(800,0.08,'square',0.06);
      setTimeout(()=>beep(500,0.10,'square',0.06),80);
      setTimeout(()=>beep(220,0.15,'square',0.05),180);
    }
    function sfxBoost(){ // quick arpeggio
      beep(660,0.06,'triangle',0.05);
      setTimeout(()=>beep(880,0.06,'triangle',0.05),70);
      setTimeout(()=>beep(1046,0.06,'triangle',0.05),140);
    }

    // ------------- UTIL -------------
    function intersects(a, b){
      const boxA = new THREE.Box3().setFromObject(a);
      const boxB = new THREE.Box3().setFromObject(b);
      return boxA.intersectsBox(boxB);
    }

    // ------------- LOOP -------------
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.05, (now-last)/1000); last = now;
      requestAnimationFrame(tick);
      if (gameOver) return;

      // Move lane marks & buildings for motion feel
      markings.forEach(m=>{
        m.position.z += speed*6;
        if(m.position.z > 6) m.position.z -= 8*60; // recycle
      });
      buildings.forEach(b=>{
        b.position.z += speed*4;
        if(b.position.z > 10) b.position.z -= 25*20;
      });

      // Car controls
      if (keys['ArrowLeft'])  car.position.x = Math.max(car.position.x-0.14, -roadW/2+1);
      if (keys['ArrowRight']) car.position.x = Math.min(car.position.x+0.14,  roadW/2-1);
      if (keys['ArrowUp'])    speed = Math.min(speed + 0.002, 0.6);
      if (keys['ArrowDown'])  speed = Math.max(speed - 0.003, 0.12);

      // Score
      score += Math.floor(speed*20);
      scoreEl.textContent = 'Score: ' + score;

      // Spawn logic
      obsTimer += dt; boostTimer += dt;
      if (obsTimer > 1.6){ obsTimer = 0; spawnObstacle(); }
      if (boostTimer > 4.2){ boostTimer = 0; if (Math.random()>0.35) spawnBooster(); }

      // Move objects
      for (let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.position.z += speed*10;
        if (o.position.z > 15){
          scene.remove(o); obstacles.splice(i,1);
          continue;
        }
        if (intersects(car,o)){
          gameOver = true;
          sfxCrash();
          stopMusic();
          finalEl.textContent = 'Score: ' + score;
          goBox.style.display = 'grid';
        }
      }
      for (let i=boosters.length-1;i>=0;i--){
        const b = boosters[i];
        b.position.z += speed*10;
        if (b.position.z > 15){
          scene.remove(b); boosters.splice(i,1);
          continue;
        }
        if (intersects(car,b)){
          speed = Math.min(speed + 0.06, 0.8);
          sfxBoost();
          scene.remove(b); boosters.splice(i,1);
        }
      }

      renderer.render(scene, camera);
    }
    requestAnimationFrame(tick);

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
